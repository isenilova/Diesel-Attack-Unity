#ifndef SUPERFLOWMAP_CG_INCLUDED
#define SUPERFLOWMAP_CG_INCLUDED 

#include "UnityCG.cginc"
struct FlowmapInfo{
	float4 flowmap;
	float2 flowDir;
	float flowPhase0, flowPhase1, flowLerp;
};

float _EditorTime;

inline void GetFlowmapValues (float2 flowUV, sampler2D flowTex, sampler2D noiseTex, float noiseScale, float2 noiseTiling,
	float flowSpeed, float animLength, out float2 flowDir, out float4 flowmap, out float flowPhase0, out float flowPhase1, out float flowLerp){
//	offset the cycle reset to prevent pulsing		
	half phaseOffset = noiseScale * tex2D (noiseTex, flowUV * noiseTiling).g;
//	uses information about the flowmap generator to offset uvs so that they match the flowmap generator in world space
	flowmap = tex2D (flowTex, flowUV);
	flowDir = (flowmap.xy * 2 - 1) * flowSpeed.xx;
	flowDir.x = clamp(flowDir.x, -1, 1);
	flowDir.y = clamp(flowDir.y, -1, 1);
//	_EditorTime is assigned by an EditorShaderTime component in the scene, this allows the flowmap to work in the editor when not playing the game
//	When the game is playing _EditorTime will be 0
//	_AnimLength controls the length of a time cycle
//	frac loops the value from 0->1
	flowPhase0 = frac(phaseOffset + (_Time.y + _EditorTime) / animLength);
	flowPhase1 = frac(phaseOffset + (_Time.y + _EditorTime) / animLength + 0.5);
	flowLerp = abs(0.5 - flowPhase0) * 2;
} 

inline half3 GetFlowmapNormalsVelocityScaled (float2 flowUV, sampler2D normalTex, float2 tiling, float2 flowDir, float4 flowmap, float flowPhase0, float flowPhase1, float flowLerp){
//	lerp between two normal maps, fading out when the uvs are most distorted to the other normal map
	half4 detailNormalTex0 = tex2D (normalTex, flowUV * tiling + flowDir * flowPhase0);
	half4 detailNormalTex1 = tex2D (normalTex, flowUV * tiling + flowDir * flowPhase1);
	return lerp(float3(0,0,1), UnpackNormal(lerp (detailNormalTex0, detailNormalTex1, flowLerp)), clamp(pow(length(flowDir), 2), 0.1, 1));
}

inline half3 GetFlowmapNormals (float2 flowUV, sampler2D normalTex, float2 tiling, float2 flowDir, float4 flowmap, float flowPhase0, float flowPhase1, float flowLerp){
//	lerp between two normal maps, fading out when the uvs are most distorted to the other normal map
	half4 detailNormalTex0 = tex2D (normalTex, flowUV * tiling + flowDir * flowPhase0);
	half4 detailNormalTex1 = tex2D (normalTex, flowUV * tiling + flowDir * flowPhase1);
	return UnpackNormal(lerp (detailNormalTex0, detailNormalTex1, flowLerp));
} 

inline half3 GetFlowmapNormalsOffsetPhase (float2 flowUV, sampler2D normalTex, float2 tiling, float2 flowDir, float4 flowmap, float flowPhase0, float flowPhase1, float flowLerp){
//	lerp between two normal maps, fading out when the uvs are most distorted to the other normal map
	half4 detailNormalTex0 = tex2D (normalTex, flowUV * tiling + flowDir * (flowPhase0 * 2 - 1));
	half4 detailNormalTex1 = tex2D (normalTex, flowUV * tiling + flowDir * (flowPhase1 * 2 - 1) + 0.5);
	return UnpackNormal(lerp (detailNormalTex0, detailNormalTex1, flowLerp));
}

inline half3 GetFlowmapDiffuse (float2 flowUV, sampler2D diffuseTex, float2 tiling, float2 flowDir, float flowPhase0, float flowPhase1, float flowLerp){
//	lerp between two diffuse textures, offsetting the phase by a half step, works better for diffuse
	half4 detailNormalTex0 = tex2D (diffuseTex, flowUV * tiling + flowDir * (flowPhase0 * 2 - 1));
	half4 detailNormalTex1 = tex2D (diffuseTex, flowUV * tiling + flowDir * (flowPhase1 * 2 - 1) + 0.5);
	return lerp (detailNormalTex0, detailNormalTex1, flowLerp);
}

inline half Fresnel (float3 viewDir, float3 normal, float bias){
	return lerp(pow(1.001 - dot(normalize(viewDir), normal), 4), 1, bias);
}

void SpecCube (inout SurfaceOutput o, half3 specColor, float3 viewDir, float3 reflVector, float smoothness, samplerCUBE envmap){
	o.Gloss = specColor.rgb * Fresnel(viewDir, o.Normal, 0.3);
	o.Emission = o.Gloss * texCUBE (envmap, reflVector).rgb;
	o.Specular = smoothness;
}

inline float4 GetFoam (float2 flowUV, float4 flowmap, float2 flowDir, float flowPhase0, float flowPhase1, float flowLerp, sampler2D foamTex, float4 foamColor, float2 foamTiling, float foamSpeed, float3 normal){
//	lerp between two foam textures, distorted by the normal and moving slower than the waves
//	the phase is offset by 50%, this works better when using diffuse textures
	half4 foamTex0 = tex2D (foamTex, flowUV * foamTiling + flowDir * (flowPhase0 * 2 - 1) * foamSpeed + normal * 0.01);
	half4 foamTex1 = tex2D (foamTex, flowUV * foamTiling + flowDir * (flowPhase1 * 2 - 1) * foamSpeed + normal * 0.01 + 0.5);
	float4 foam = lerp(foamTex0, foamTex1, flowLerp);
//	the foam mask is based on the green channel of the foam texture
	foam.a = foam.g * foamColor.a;
//	the foam diffuse is based on the red channel of the foam texture
	foam.rgb = foam.r * foamColor.rgb;
//	use the foam mask generated by Flowmap Generator, stored in the blue channel of the flowmap texture
	foam.a *= flowmap.b; 
//	sharpen the resulting foam mask
	foam.a = smoothstep (0.02, 0.1, foam.a);
	return foam;
}

inline float2 GetScreenUV (float4 screenPos){
	return (screenPos.xy / screenPos.w);
}

inline float GetSceneZ (float2 screenUV, sampler2D cameraDepthTexture){
	return LinearEyeDepth(UNITY_SAMPLE_DEPTH(tex2D(cameraDepthTexture, screenUV)));
}

inline float GetEdgeFade (float4 screenPos, float sceneZ, float edgeFadeDepth, float edgeFadePower){
	return saturate(pow(saturate(sceneZ-screenPos.z) * 1/edgeFadeDepth, max(0.5, edgeFadePower)));
}

inline void DepthFogLinear (inout SurfaceOutput o, float4 screenPos, float sceneZ, float2 screenUV, sampler2D grabPassTexture, 
		float edgeFade, float fogStart, float fogEnd, float4 fogColor, float distortion, out float fog, out float3 background){
	
	fog = 1 - saturate((fogEnd - (sceneZ-screenPos.z)) / (fogEnd - fogStart));
	float distort = saturate((sceneZ-screenPos.z) * 0.5) * distortion;
//	fix for forward rendering on unity 3.5
	#if UNITY_UV_STARTS_AT_TOP
	if(_ProjectionParams.x == 1){
		screenUV = float2(screenUV.x, 1-screenUV.y);
	}
	#endif
	background = tex2D (grabPassTexture, screenUV + o.Normal.xy * distort).rgb;
	background = lerp(background, fogColor.rgb, fog * edgeFade);
 }
 
#endif
